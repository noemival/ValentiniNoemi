/*
 * A resource is called by two actors that send a request cmd:cmd(X)
 * The resource elaborates the request 
 * 	by updating its internal CoAP-observable info  
 * 	and sends the answer replytocmd to the sender of the request 
 * 
 * NOTE that IF WE USE MQTT, the callers subsystem starts also 
 * when the resource is not active 
 * OTHERWISE, the callers subsystem does not start until the ctxresource
 * is activated.
 *
 */ 
System /*-trace*/ -msglog  callersealone
 	//"tcp://mqtt.eclipse.org:1883"
	//mqtt.eclipse.org
	//tcp://test.mosquitto.org
	//mqtt.fluux.io 
	//"tcp://broker.hivemq.com" 
 
// mqttBroker "broker.hivemq.com" : 1883 eventTopic "unibo/radar"
 
//Request cmd 		: cmd(X) // X =  w | s | a | d | h
//Reply   replytocmd  : replytocmd(X)
//Event   alarm       : alarm(X) 
 //Request  polar        : polar(D,A) 
 
 Dispatch ledCmd : ledCmd(X)   
 Event sonarAlarm : sonarAlarm(X)
 
Context ctxcallers  ip [ host= "localhost" port= 8050 ]  
//Context ctxradargui ip [ host= "localhost"   port= 8038 ]  

Context ctxsonarobserver   ip [host="localhost"    port=8083]   

//Context ctxradargui ip [ host= "localhost" port= 8038 ]   
//ExternalQActor radargui context ctxradargui
//ExternalQActor sonarobserver context ctxsonarobserver


/*
 * caller1
 */
/*QActor caller1 context ctxcallers {
	State s0 initial {    
  		 println("caller1 request cmd ")
		 request resource -m cmd : cmd(caller1) 
	}
	Transition t0 
		whenReply replytocmd -> handleReply 
  	
	State handleReply{
		printCurrentMessage
   	}

  
}

/*
 * caller2
 */
QActor caller2 context ctxcallers {
	[# 
		var odd         = true
		
	#]
	State s0 initial {    
  		 println("caller2 request cmd ")
		// request radargui -m polar : polar(caller2) 
	}
	Goto waitForInput
	
	State waitForInput{
		println("caller2 waiting ... ")
	}
	Transition t0 
		whenEvent sonarAlarm  -> handleAlarm
		//whenReply replytocmd -> handleReply 
	 
/* State handleReply{
		printCurrentMessage
 	} 
 	Goto waitForInput
 	*/
	State handleAlarm{
		println("---------------------------------------------------")
		printCurrentMessage
 		println("---------------------------------------------------")
 	} 	
 	Goto switchedLed
 	State switchedLed
 {
 	 		if[# odd #]{
			updateResource [# "ledCmdOn" #]
			forward led -m ledCmd : ledCmd(on)
  		}else{
			updateResource [# "ledCmdOff" #]
			forward led -m ledCmd : ledCmd(off)  			
  		}
		[# odd = !odd #]
 } Goto waitForInput
 }
 
 
 /*
 * Executes the command (dispatch) ledCmd : ledCmd(X) X=on/off
 * with reference to a led on pin BCM25 (wpi6) GND pyhsicalPIN-20
 */ 
QActor led context ctxcallers {  
[# 
	var counter = 0 
	//val leddev = resources.bls.kotlin.led.create()	
#]    
	State s0 initial {  
		//run resources.it.unibo.bls.devices.gui.LedAsGui.create( )
 		println("led started")
 		updateResource [# "led OFF "#]
	} 
	Goto waitCmd   
	 
	State waitCmd{  
		//println("led waits ...") 
	}   
	Transition t0     
 		whenMsg ledCmd            -> handleLedCmd
  	  
	State  handleLedCmd{  
		printCurrentMessage   
		
		onMsg ( ledCmd : ledCmd(X) ) { 
			[# val Cmd = payloadArg(0)
			   counter++
			#]
			if[# Cmd == "on" #] {  
 				println( "led ON counter=$counter" )
				//machineExec "\"sudo bash led25GpioTurnOn.sh\""
 				updateResource [# "ledOn ${counter}" #]
			}else{
				println( "led OFF counter=$counter" )
			//	machineExec "\"sudo bash led25GpioTurnOff.sh\""
				updateResource [# "ledOff ${counter}" #]
			}
		}
	}	
	Goto waitCmd        
}

 
 